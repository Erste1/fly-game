<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GD Telegram Pro</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root { --main-color: #2af5ff; --bg-color: #001a2d; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: var(--bg-color); font-family: 'Arial Black', sans-serif; }
        canvas { display: block; touch-action: none; }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0, 0, 0, 0.7); z-index: 10;
        }
        
        .menu-title {
            color: white; font-size: 42px; text-shadow: 4px 4px #000;
            margin-bottom: 20px; text-align: center;
        }

        .btn-start {
            padding: 15px 50px; font-size: 28px; background: #2ecc71;
            color: white; border: 4px solid #1a5e3a; border-radius: 12px;
            cursor: pointer; text-shadow: 2px 2px #000; transition: 0.2s;
        }

        .btn-start:active { transform: scale(0.95); }

        #stats {
            position: absolute; top: 15px; width: 100%; text-align: center;
            color: white; font-size: 22px; z-index: 5; pointer-events: none;
            text-shadow: 2px 2px #000;
        }

        .record-text { font-size: 16px; color: #ffce00; margin-top: 8px; }
    </style>
</head>
<body>

    <div id="stats">
        <div id="current-score">SCORE: 0</div>
        <div id="best-score" class="record-text">BEST: 0</div>
    </div>

    <div id="overlay">
        <div class="menu-title">GEOMETRY DASH<br>TMA</div>
        <button class="btn-start" onclick="startGame()">START GAME</button>
        <div id="menu-record" class="record-text">BEST: 0</div>
    </div>

    <canvas id="game"></canvas>

<script>
    // Инициализация Telegram WebApp
    const tg = window.Telegram.WebApp;
    tg.expand(); // Развернуть на весь экран
    tg.MainButton.setText("ЗАКРЫТЬ ИГРУ").hide();

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let gameState = 'MENU';
    let score = 0;
    let bestScore = localStorage.getItem('gd_best') || 0;
    
    function updateRecordDisplay() {
        document.querySelectorAll('.record-text').forEach(el => el.innerText = `BEST: ${bestScore}`);
    }
    updateRecordDisplay();

    const config = {
        gravity: 0.8,
        jumpPower: -13.5,
        groundY: canvas.height - 80,
        speed: 7.5,
        cubeSize: 42
    };

    const player = {
        x: 80, y: 0, vy: 0, rot: 0, 
        particles: [],
        reset() {
            this.y = config.groundY - config.cubeSize;
            this.vy = 0; this.rot = 0; this.particles = [];
        }
    };

    let obstacles = [];
    let frame = 0;

    class Particle {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.size = Math.random() * 7 + 4;
            this.alpha = 1;
            this.vx = -4 - Math.random() * 2;
        }
        draw() {
            ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
            ctx.fillRect(this.x, this.y, this.size, this.size);
        }
    }

    class Obstacle {
        constructor(type) {
            this.type = type; 
            this.x = canvas.width + 100;
            this.w = 42; this.h = 42;
            this.y = type === 'spike' ? config.groundY : config.groundY - 90;
        }
        draw() {
            if (this.type === 'spike') {
                ctx.fillStyle = '#ff4444';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + this.w/2, this.y - this.h);
                ctx.lineTo(this.x + this.w, this.y);
                ctx.fill();
                ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.stroke();
            } else {
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(this.x, this.y - this.h, this.w, this.h);
                ctx.strokeStyle = 'white'; ctx.strokeRect(this.x, this.y - this.h, this.w, this.h);
            }
        }
    }

    function startGame() {
        gameState = 'PLAYING';
        overlay.style.display = 'none';
        tg.MainButton.hide();
        score = 0;
        obstacles = [];
        player.reset();
        document.getElementById('current-score').innerText = `SCORE: 0`;
    }

    function gameOver() {
        gameState = 'MENU';
        overlay.style.display = 'flex';
        
        // Сохраняем рекорд
        if (score > bestScore) {
            bestScore = score;
            localStorage.setItem('gd_best', bestScore);
        }
        updateRecordDisplay();

        // Отправка данных в Telegram
        tg.MainButton.show();
        tg.sendData(JSON.stringify({
            event: "game_over",
            score: score,
            best_score: bestScore
        }));
    }

    tg.onEvent('mainButtonClicked', function(){
        tg.close();
    });

    function jump() {
        if (gameState !== 'PLAYING') return;
        if (player.y >= config.groundY - config.cubeSize - 5) {
            player.vy = config.jumpPower;
        }
    }

    function loop() {
        // Фон
        ctx.fillStyle = '#0072ff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Пол
        ctx.fillStyle = '#005bb5';
        ctx.fillRect(0, config.groundY, canvas.width, canvas.height);
        ctx.strokeStyle = 'white'; ctx.lineWidth = 4;
        ctx.strokeRect(-5, config.groundY, canvas.width + 10, 2);

        if (gameState === 'PLAYING') {
            player.vy += config.gravity;
            player.y += player.vy;

            if (player.y > config.groundY - config.cubeSize) {
                player.y = config.groundY - config.cubeSize;
                player.vy = 0; player.rot = 0;
            } else {
                player.rot += 6;
            }

            // Шлейф
            if (frame % 2 === 0) player.particles.push(new Particle(player.x, player.y + 15 + Math.random()*10));
            player.particles.forEach((p, i) => {
                p.x += p.vx; p.alpha -= 0.05;
                if (p.alpha <= 0) player.particles.splice(i, 1);
                p.draw();
            });

            // Спавн
            if (frame % 75 === 0) {
                const type = Math.random() > 0.8 ? 'block' : 'spike';
                obstacles.push(new Obstacle(type));
            }

            obstacles.forEach((obs, i) => {
                obs.x -= config.speed;
                obs.draw();

                // Коллизия
                if (player.x + 30 > obs.x && player.x + 10 < obs.x + obs.w &&
                    player.y + config.cubeSize > (obs.y - obs.h)) {
                    gameOver();
                }

                if (obs.x < -100) {
                    obstacles.splice(i, 1);
                    score++;
                    document.getElementById('current-score').innerText = `SCORE: ${score}`;
                }
            });
            frame++;
        }

        // Отрисовка куба
        ctx.save();
        ctx.translate(player.x + 21, player.y + 21);
        ctx.rotate(player.rot * Math.PI / 180);
        ctx.fillStyle = '#1fff1f';
        ctx.fillRect(-21, -21, 42, 42);
        ctx.strokeStyle = 'black'; ctx.lineWidth = 3; ctx.strokeRect(-21, -21, 42, 42);
        // Лицо
        ctx.fillStyle = 'black'; ctx.fillRect(-11, -12, 7, 7); ctx.fillRect(4, -12, 7, 7); ctx.fillRect(-10, 7, 20, 3);
        ctx.restore();

        requestAnimationFrame(loop);
    }

    window.addEventListener('mousedown', jump);
    window.addEventListener('touchstart', (e) => { e.preventDefault(); jump(); }, {passive: false});
    
    player.reset();
    loop();
</script>
</body>
</html>
